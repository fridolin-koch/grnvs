package ipv6

import (
	"bytes"
	"testing"
)

func TestParseHeader(t *testing.T) {
	p := []byte{
		// IPv6 header 0:40
		0x60, 0x00, 0x00, 0x00,
		0x00, 0x08, 0x00, 0x38,
		0x2a, 0x01, 0x04, 0xf8,
		0x01, 0x01, 0x11, 0x90,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x02,
		0x20, 0x01, 0x0a, 0x60,
		0x16, 0xaf, 0x9a, 0x01,
		0x02, 0x0c, 0x29, 0xff,
		0xfe, 0x71, 0xb0, 0x1e,
		// hop-by-hop extension header 40:50
		0x2b, 0x00, 0x01, 0x02,
		0x03, 0x04, 0x05, 0x6,
		0x07, 0x08,
		// routing extension header 50:62
		0x3c, 0x02, 0x26, 0x05,
		0x03, 0x04, 0x05, 0x6,
		0x07, 0x08, 0x0a, 0x0b,
		// destination extenstion header 62:72
		0x3a, 0x00, 0x01, 0x02,
		0x03, 0x04, 0x05, 0x6,
		0x07, 0x08,
		// imcp payload 72:88
		0x80, 0x00, 0x43, 0x33,
		0x1e, 0x43, 0x00, 0x0c,
		0x55, 0x84, 0x20, 0x29,
		0x00, 0x0b, 0xce, 0xce,
	}
	// try parsing it
	h, o, err := ParseHeader(p)
	if err != nil {
		t.Error(err.Error())
	}
	if o != 72 {
		t.Error("Returned offset is invalid")
	}
	// validate extension
	if !isExtensionHeaderEqual(p[40:50], h.ExtensionHeaders[0]) {
		t.Error("Parsing Hop-by-Hop header failed")
	}
	if !isExtensionHeaderEqual(p[50:62], h.ExtensionHeaders[1]) {
		t.Error("Parsing Routing header failed")
	}
	if !isExtensionHeaderEqual(p[62:72], h.ExtensionHeaders[2]) {
		t.Error("Parsing Destination header failed")
	}
}

func isExtensionHeaderEqual(e []byte, a ExtensionHeader) bool {
	return e[0] == a.NextHeader && e[1] == a.ExtensionLength && bytes.Equal(e[2:], a.Data)
}
